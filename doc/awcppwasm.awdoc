AW{"type":"mjmd"}
WebAssembly
===========

Using [WebAssembly](https://webassembly.org/) it is possbile to run the compiled C++ code in the browser. This makes it possible to produce documentation that viewers can interact with without the use of a server. However, the C++ has to be compiled to webassembly using a server. Once compiled, the WebAssembly can be run in the browser taking paramaters from the document.

Experimental
------------

To get started with WebAssembly support it was necessary to understand how the WebAssembly, or *wasm*, could be integrated into an AwDoc. Two important concepts had to be proven before investing further development effort:

- Running the wasm
- Passing JSON to and from the wasm

There is currently no back-end support for building the wasm binary in AndrewWIDE. The following code was built manually.

AW{"type":"awcppwasm"}
#include <stdlib.h>
#include <string.h>
#include <emscripten.h>


char *g_str_query;
char *g_str_response;

EMSCRIPTEN_KEEPALIVE
void set_query(char* query)
{
    g_str_query = malloc(strlen(query)+1);
    if(g_str_query)
    {
        char* p=query;
        char* o=g_str_query;
        while(*p != '\0')
        {
            *o = (*p);
            o++;
            p++;
        } 
        *o = '\0';
    }
}

EMSCRIPTEN_KEEPALIVE
char* get_response()
{
    return g_str_response;
}

EMSCRIPTEN_KEEPALIVE
void myplot()
{
    g_str_response = "{\"data\":[0,0.0209774,0.0419455,0.0628952,0.0838172,0.104702,0.125541,0.146325,0.167045,0.18769,-0.146325,-0.125541,-0.104702,-0.0838169,-0.0628949,-0.0419452,-0.020977,3.49691e-7],\"type\":\"plot\",\"id\":\"plot_14\"}";
}
AW{"type":"mjmd"}
The above C++ code was saved in a file called **str.cpp** and compiled using:

```
$ emcc str.c -s WASM=1 -s -o str.js -Oz -s EXPORTED_RUNTIME_METHODS="['ccall']" --minify=0
```

AW{"type":"mjmd"}
The wasm binary is converted to base-64 using:

```
$ cat str.wasm | base64 -w0
```

The contents of the base64 encoded wasm and the runtime JavaScript code are pasted into AwDoc sections below:
AW{"type":"wasm-b64"}
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
AW{"type":"wasm-rt"}
var Module = typeof Module !== "undefined" ? Module : {};

var moduleOverrides = {};

var key;

for (key in Module) {
 if (Module.hasOwnProperty(key)) {
  moduleOverrides[key] = Module[key];
 }
}

var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = function(status, toThrow) {
 throw toThrow;
};

var ENVIRONMENT_IS_WEB = false;

var ENVIRONMENT_IS_WORKER = false;

var ENVIRONMENT_IS_NODE = false;

var ENVIRONMENT_IS_SHELL = false;

ENVIRONMENT_IS_WEB = typeof window === "object";

ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";

ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

var scriptDirectory = "";

function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}

var read_, readAsync, readBinary, setWindowTitle;

var nodeFS;

var nodePath;

if (ENVIRONMENT_IS_NODE) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = require("path").dirname(scriptDirectory) + "/";
 } else {
  scriptDirectory = __dirname + "/";
 }
 read_ = function shell_read(filename, binary) {
  if (!nodeFS) nodeFS = require("fs");
  if (!nodePath) nodePath = require("path");
  filename = nodePath["normalize"](filename);
  return nodeFS["readFileSync"](filename, binary ? null : "utf8");
 };
 readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
   ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
 };
 if (process["argv"].length > 1) {
  thisProgram = process["argv"][1].replace(/\\/g, "/");
 }
 arguments_ = process["argv"].slice(2);
 if (typeof module !== "undefined") {
  module["exports"] = Module;
 }
 process["on"]("uncaughtException", function(ex) {
  if (!(ex instanceof ExitStatus)) {
   throw ex;
  }
 });
 process["on"]("unhandledRejection", abort);
 quit_ = function(status) {
  process["exit"](status);
 };
 Module["inspect"] = function() {
  return "[Emscripten Module object]";
 };
} else if (ENVIRONMENT_IS_SHELL) {
 if (typeof read != "undefined") {
  read_ = function shell_read(f) {
   return read(f);
  };
 }
 readBinary = function readBinary(f) {
  var data;
  if (typeof readbuffer === "function") {
   return new Uint8Array(readbuffer(f));
  }
  data = read(f, "binary");
  assert(typeof data === "object");
  return data;
 };
 if (typeof scriptArgs != "undefined") {
  arguments_ = scriptArgs;
 } else if (typeof arguments != "undefined") {
  arguments_ = arguments;
 }
 if (typeof quit === "function") {
  quit_ = function(status) {
   quit(status);
  };
 }
 if (typeof print !== "undefined") {
  if (typeof console === "undefined") console = {};
  console.log = print;
  console.warn = console.error = typeof printErr !== "undefined" ? printErr : print;
 }
} else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (typeof document !== "undefined" && document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 {
  read_ = function(url) {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, false);
   xhr.send(null);
   return xhr.responseText;
  };
  if (ENVIRONMENT_IS_WORKER) {
   readBinary = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.responseType = "arraybuffer";
    xhr.send(null);
    return new Uint8Array(xhr.response);
   };
  }
  readAsync = function(url, onload, onerror) {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, true);
   xhr.responseType = "arraybuffer";
   xhr.onload = function() {
    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
     onload(xhr.response);
     return;
    }
    onerror();
   };
   xhr.onerror = onerror;
   xhr.send(null);
  };
 }
 setWindowTitle = function(title) {
  document.title = title;
 };
} else {}

var out = Module["print"] || console.log.bind(console);

var err = Module["printErr"] || console.warn.bind(console);

for (key in moduleOverrides) {
 if (moduleOverrides.hasOwnProperty(key)) {
  Module[key] = moduleOverrides[key];
 }
}

moduleOverrides = null;

if (Module["arguments"]) arguments_ = Module["arguments"];

if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

if (Module["quit"]) quit_ = Module["quit"];

var wasmBinary;

if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

var noExitRuntime = Module["noExitRuntime"] || true;

if (typeof WebAssembly !== "object") {
 abort("no native wasm support detected");
}

var wasmMemory;

var ABORT = false;

var EXITSTATUS;

function assert(condition, text) {
 if (!condition) {
  abort("Assertion failed: " + text);
 }
}

function getCFunc(ident) {
 var func = Module["_" + ident];
 assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
 return func;
}

function ccall(ident, returnType, argTypes, args, opts) {
 var toC = {
  "string": function(str) {
   var ret = 0;
   if (str !== null && str !== undefined && str !== 0) {
    var len = (str.length << 2) + 1;
    ret = stackAlloc(len);
    stringToUTF8(str, ret, len);
   }
   return ret;
  },
  "array": function(arr) {
   var ret = stackAlloc(arr.length);
   writeArrayToMemory(arr, ret);
   return ret;
  }
 };
 function convertReturnValue(ret) {
  if (returnType === "string") return UTF8ToString(ret);
  if (returnType === "boolean") return Boolean(ret);
  return ret;
 }
 var func = getCFunc(ident);
 var cArgs = [];
 var stack = 0;
 if (args) {
  for (var i = 0; i < args.length; i++) {
   var converter = toC[argTypes[i]];
   if (converter) {
    if (stack === 0) stack = stackSave();
    cArgs[i] = converter(args[i]);
   } else {
    cArgs[i] = args[i];
   }
  }
 }
 var ret = func.apply(null, cArgs);
 ret = convertReturnValue(ret);
 if (stack !== 0) stackRestore(stack);
 return ret;
}

var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heap, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var endPtr = idx;
 while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
 if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
  return UTF8Decoder.decode(heap.subarray(idx, endPtr));
 } else {
  var str = "";
  while (idx < endPtr) {
   var u0 = heap[idx++];
   if (!(u0 & 128)) {
    str += String.fromCharCode(u0);
    continue;
   }
   var u1 = heap[idx++] & 63;
   if ((u0 & 224) == 192) {
    str += String.fromCharCode((u0 & 31) << 6 | u1);
    continue;
   }
   var u2 = heap[idx++] & 63;
   if ((u0 & 240) == 224) {
    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
   } else {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
   }
   if (u0 < 65536) {
    str += String.fromCharCode(u0);
   } else {
    var ch = u0 - 65536;
    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
   }
  }
 }
 return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   heap[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   heap[outIdx++] = 192 | u >> 6;
   heap[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   heap[outIdx++] = 224 | u >> 12;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   heap[outIdx++] = 240 | u >> 18;
   heap[outIdx++] = 128 | u >> 12 & 63;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  }
 }
 heap[outIdx] = 0;
 return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function writeArrayToMemory(array, buffer) {
 HEAP8.set(array, buffer);
}

var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
 buffer = buf;
 Module["HEAP8"] = HEAP8 = new Int8Array(buf);
 Module["HEAP16"] = HEAP16 = new Int16Array(buf);
 Module["HEAP32"] = HEAP32 = new Int32Array(buf);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}

var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;

var wasmTable;

var __ATPRERUN__ = [];

var __ATINIT__ = [];

var __ATPOSTRUN__ = [];

var runtimeInitialized = false;

function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
 runtimeInitialized = true;
 callRuntimeCallbacks(__ATINIT__);
}

function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}

function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}

var runDependencies = 0;

var runDependencyWatcher = null;

var dependenciesFulfilled = null;

function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}

function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}

Module["preloadedImages"] = {};

Module["preloadedAudios"] = {};

function abort(what) {
 if (Module["onAbort"]) {
  Module["onAbort"](what);
 }
 what += "";
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
 var e = new WebAssembly.RuntimeError(what);
 throw e;
}

var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
 return filename.startsWith(dataURIPrefix);
}

function isFileURI(filename) {
 return filename.startsWith("file://");
}

var wasmBinaryFile;

wasmBinaryFile = "str.wasm";

if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary(file) {
 try {
  if (file == wasmBinaryFile && wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
   return readBinary(file);
  } else {
   throw "both async and sync fetching of the wasm failed";
  }
 } catch (err) {
  abort(err);
 }
}

function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
  if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    if (!response["ok"]) {
     throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
    }
    return response["arrayBuffer"]();
   }).catch(function() {
    return getBinary(wasmBinaryFile);
   });
  } else {
   if (readAsync) {
    return new Promise(function(resolve, reject) {
     readAsync(wasmBinaryFile, function(response) {
      resolve(new Uint8Array(response));
     }, reject);
    });
   }
  }
 }
 return Promise.resolve().then(function() {
  return getBinary(wasmBinaryFile);
 });
}

function createWasm() {
 var info = {
  "a": asmLibraryArg
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  wasmMemory = Module["asm"]["b"];
  updateGlobalBufferAndViews(wasmMemory.buffer);
  wasmTable = Module["asm"]["g"];
  addOnInit(Module["asm"]["c"]);
  removeRunDependency("wasm-instantiate");
 }
 addRunDependency("wasm-instantiate");
 function receiveInstantiationResult(result) {
  receiveInstance(result["instance"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then(function(binary) {
   var result = WebAssembly.instantiate(binary, info);
   return result;
  }).then(receiver, function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  });
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiationResult, function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     return instantiateArrayBuffer(receiveInstantiationResult);
    });
   });
  } else {
   return instantiateArrayBuffer(receiveInstantiationResult);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   return false;
  }
 }
 instantiateAsync();
 return {};
}

function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback(Module);
   continue;
  }
  var func = callback.func;
  if (typeof func === "number") {
   if (callback.arg === undefined) {
    wasmTable.get(func)();
   } else {
    wasmTable.get(func)(callback.arg);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}

function abortOnCannotGrowMemory(requestedSize) {
 abort("OOM");
}

function _emscripten_resize_heap(requestedSize) {
 var oldSize = HEAPU8.length;
 requestedSize = requestedSize >>> 0;
 abortOnCannotGrowMemory(requestedSize);
}

var asmLibraryArg = {
 "a": _emscripten_resize_heap
};

var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
 return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["c"]).apply(null, arguments);
};

var _set_query = Module["_set_query"] = function() {
 return (_set_query = Module["_set_query"] = Module["asm"]["d"]).apply(null, arguments);
};

var _get_response = Module["_get_response"] = function() {
 return (_get_response = Module["_get_response"] = Module["asm"]["e"]).apply(null, arguments);
};

var _myplot = Module["_myplot"] = function() {
 return (_myplot = Module["_myplot"] = Module["asm"]["f"]).apply(null, arguments);
};

var stackSave = Module["stackSave"] = function() {
 return (stackSave = Module["stackSave"] = Module["asm"]["h"]).apply(null, arguments);
};

var stackRestore = Module["stackRestore"] = function() {
 return (stackRestore = Module["stackRestore"] = Module["asm"]["i"]).apply(null, arguments);
};

var stackAlloc = Module["stackAlloc"] = function() {
 return (stackAlloc = Module["stackAlloc"] = Module["asm"]["j"]).apply(null, arguments);
};

Module["ccall"] = ccall;

var calledRun;

function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}

dependenciesFulfilled = function runCaller() {
 if (!calledRun) run();
 if (!calledRun) dependenciesFulfilled = runCaller;
};

function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) {
  return;
 }
 function doRun() {
  if (calledRun) return;
  calledRun = true;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout(function() {
   setTimeout(function() {
    Module["setStatus"]("");
   }, 1);
   doRun();
  }, 1);
 } else {
  doRun();
 }
}

Module["run"] = run;

if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}

run();
