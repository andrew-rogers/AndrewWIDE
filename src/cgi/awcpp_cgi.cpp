/*
    AndrewWIDE - AWCPP operations CGI
    Copyright (C) 2021  Andrew Rogers

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

#include "cgi_post.h"
#include "filesystem.h"

#include <fstream>

using namespace std;

void processQuery( Json& query );
std::string cppMain();
int make( const std::string& makefile, const std::string& cgi );

int main(int argc, char *args[])
{
    getQuery();
    
    // Process the query
    processQuery( g_query );

    sendResponse();

    return 0;
}

void processQuery( Json& query )
{
    string cmd=query["cmd"].str();

    if( cmd == "build" )
    {
        auto fn = filesystem::absPath(query["awdoc"].str());
        auto dir = filesystem::stripExtension(fn);
        auto func = query["func"].str();
        auto cpp = query["cpp"].str();
        auto cgi = filesystem::stripExtension( filesystem::basename( fn ) );
        if( func.compare("globals") == 0 )
        {
            auto err = filesystem::mkdir(dir); /// @todo Check for errors
            g_response["err"]=filesystem::writeFile(dir+"/globals.h", cpp);
        }
        else if( func.compare("mk") == 0 )
        {
            auto err = filesystem::mkdir(dir); /// @todo Check for errors
            g_response["err"]=filesystem::writeFile(dir+"/includes.mk", cpp);
        }
        else
        {
            auto err = filesystem::mkdir(dir); /// @todo Check for errors

            // Create the C++ function file
            std::string global;
            filesystem::readFile(dir+"/globals.h", global); // Leave string empty if file not found.
            std::string out;
            out += global;
            out += cpp;
            err = filesystem::mkdir(dir+"/func.d"); /// @todo Check for errors
            err += filesystem::writeFile(dir+"/func.d/"+func+"_aw.cpp", out);

            // Create the C++ main
            out = cppMain();
            err += filesystem::writeFile(dir+"/"+cgi+"_awmain.cpp", out);

            // Change directory and invoke make
            auto makefile = filesystem::findAWDir()+"/lib/awcpp.makefile";
            err += filesystem::cwd(dir);
            make(makefile, cgi);

            // Get the build log
            std::string build_log;
            err += filesystem::readFile("build.log", build_log);
            g_response["build_log"]=build_log;
            g_response["err"]=err;
        }
    }
    else if( cmd == "run" )
    {
        g_response["run_output"] = "make run"; // @todo Invoke make, for now just respond with make run
    }

}

std::string cppMain()
{
    std::string out;
    out += "// This file is automatically generated by AndrewWIDE, changes may be lost.\n";
    return out;
}

int make( const std::string& makefile, const std::string& cgi )
{
#ifdef WINDOWS
    std::string cmd = "mingw32-make CGI=\""+cgi+"\" -f \""+filesystem::fixPath(makefile)+"\" > build.log 2>&1";
#else
    std::string cmd = "make CGI=\""+cgi+"\" -f \""+makefile+"\" > build.log 2>&1";
#endif
    return system(cmd.c_str());
}

