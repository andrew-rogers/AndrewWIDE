AW{"type":"awcppwasm","id":"mk","hidden":true}

TARGET = src.wasm
LDFLAGS += --no-entry

AW{"type":"awcppwasm","id":"globals","hidden":true}

#include <complex>
#include <cmath>

const std::complex<double> PI = M_PI;
const std::complex<double> j2pi(0,2.0 * M_PI);

double g_zp;

typedef WasmVector<double> vec_t;
typedef std::complex<double> complex_t;

AW{"type":"javascript"}
let wrt = {};
window.wrt = wrt;

let CStringToJS = function(cstr) {
    let buf = wrt.exports.memory.buffer;
    let heap = new Uint8Array(buf);
    let str = "";
    if (cstr==0) return "";
    let i=cstr;
    while (heap[i] > 0) str += String.fromCharCode(heap[i++]);
    return str;
};

let env = {};
env.emjs_add_response_cmd = function(src) {
    wasm.addResponseCommand(CStringToJS(src));
};

env.emjs_add_wasm_vectors = function(name, ptr) {
    new WasmVectors(CStringToJS(name), ptr);
};

env.emjs_wasm_vectors_add = function(p_wvs, name, ptr, type) {
    var wvs = WasmVectors.dict["p"+p_wvs]; // Lookup the WasmVectors to add the WasmVector to.
    wvs.addPtr(CStringToJS(name), ptr, type);
};

let wsp = {};

wsp.fd_close = function() {
    console.log("Not yet implemented");
};

wsp.fd_write = function() {
    console.log("Not yet implemented");
};

wsp.fd_seek = function() {
    console.log("Not yet implemented");
};

wsp.proc_exit = function() {
    console.log("Not yet implemented");
};

wrt.imports = {env: env, wasi_snapshot_preview1: wsp};
wrt.wasm_binary = Module.wasmBinary;
wrt.init = function() {
    wrt.wasm_binary = window.Module.wasmBinary;
    WebAssembly.instantiate(wrt.wasm_binary, wrt.imports)
    .then((result) => {
        wrt.exports = result.instance.exports;
        wrt.exports._initialize();
        wrt.exports.awcppwasm_7();
    });
};


AW{"type":"mjmd"}

A low-pass RC filter has the [Laplace](https://en.wikipedia.org/wiki/Laplace_transform) transfer function

$$H(s)=\frac{1}{1+sRC}$$

AW{"type":"mono","id":"params"}
R: 1000.0
C: 100e-9
Fs: 32000.0

AW{"type":"mjmd"}

C++ code to evaluate filter response using Laplace transform. A digital filter (created using the pole-zero placement
method) is also evaluated. Note that the code cannot be edited then executed if running server-less. This is because the
server back-end is required to compile the C++ to WebAssembly. This might be possible in the future using
[Clang in Browser](https://github.com/tbfleming/cib).

AW{"type":"awcppwasm","inputs":["params"]}

    auto p=getParameters("params");
    double RC = p.getF64("R")[0] * p.getF64("C")[0];
    double Fs = p.getF64("Fs")[0];

    auto f = linspace(0,Fs/2,1000);
    auto ah = 0.0 * f; // Create zero initialised vector same length as f for response

    for (int i=0; i<f.size(); i++)
    {
        complex_t s = j2pi * f[i];
        complex_t H = 1.0 / ( 1.0 + s * RC );
        ah[i] = abs(H);
    }

    plot(f,ah).name("Analogue");
    xlabel("Frequency (Hz)");
    ylabel("|H(f)|");

    // Pole at 1+sRC=0
    double sp = -1.0 / RC;

    // Convert pole to z-domain
    double T = 1.0/Fs;
    double zp = exp(sp*T);
    g_zp = zp; // Copy to global for pole plotting later.

    // Zero at z = -1
    double zz = -1;

    // Pass-band scaling
    double K = (1.0-zp)/(1.0-zz);

    auto dh = 0.0 * f; // Create zero initialised vector same length as f for response
    for (int i=0; i<f.size(); i++)
    {
        complex_t s = j2pi * f[i];
        complex_t z = exp(s * T);
        complex_t H = K*(z-zz)/(z-zp);
        dh[i] = abs(H);
    }

    plot(f,dh).name("Digital");

AW{"type":"awcppwasm","inputs":["params"]}

    // Input params not used.

    vec_t zx,zy,px,py;

    // Plot the zeros.
    zx.push_back(-1);
    zy.push_back(0);
    unitCircle();
    plot(zx,zy).marker("o").name("zeros");

    // Plot the poles.
    px.push_back(g_zp);
    py.push_back(0.0);
    plot(px,py).marker("x").name("poles");

